<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vaneao</title>
  <icon>https://tva2.sinaimg.cn/large/0081m2Hkly8guov8jmh4vj60fj0fk74t02.jpg</icon>
  <subtitle>minimalist | vaneao.github.io</subtitle>
  <link href="https://github.com/vaneao/vaneao.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/vaneao/vaneao.github.io/"/>
  <updated>2021-09-24T06:16:00.437Z</updated>
  <id>https://github.com/vaneao/vaneao.github.io/</id>
  
  <author>
    <name>vaneao</name>
    <email>51055521@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模拟实现Promise</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0promise/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0promise/</id>
    <published>2021-09-24T06:16:00.437Z</published>
    <updated>2021-09-24T06:16:00.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><ul><li>设定三个状态 <code>PENDING、FULFILLED、REJECTED</code> ，只能由<code>PENDING</code>改变为<code>FULFILLED、REJECTED</code>，并且只能改变一次</li><li><code>MyPromise</code>接收一个函数<code>executor</code>，<code>executor</code>有两个参数<code>resolve</code>方法和<code>reject</code>方法</li><li><code>resolve</code>将<code>PENDING</code>改变为<code>FULFILLED</code></li><li><code>reject</code>将<code>PENDING</code>改变为<code>FULFILLED</code></li><li><code>promise</code>变为<code>FULFILLED</code>状态后具有一个唯一的<code>value</code></li><li><code>promise</code>变为<code>REJECTED</code>状态后具有一个唯一的<code>reason</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.state = PENDING;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = FULFILLED;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = REJECTED;</span><br><span class="line">      <span class="built_in">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><ul><li><code>then</code>方法接受两个参数<code>onFulfilled、onRejected</code>，它们分别在状态由<code>PENDING</code>改变为<code>FULFILLED、REJECTED</code>后调用</li><li>一个<code>promise</code>可绑定多个<code>then</code>方法</li><li><code>then</code>方法可以同步调用也可以异步调用</li><li>同步调用：状态已经改变，直接调用<code>onFulfilled</code>方法</li><li>异步调用：状态还是<code>PENDING</code>，将<code>onFulfilled、onRejected</code>分别加入两个函数数组<code>onFulfilledCallbacks、onRejectedCallbacks</code>，当异步调用<code>resolve</code>和<code>reject</code>时，将两个数组中绑定的事件循环执行。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.state = PENDING;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">    <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = FULFILLED;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">fun</span> =&gt;</span> &#123;</span><br><span class="line">          fun();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = REJECTED;</span><br><span class="line">        <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fun</span> =&gt;</span> &#123;</span><br><span class="line">          fun();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PENDING:</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="then方法异步调用"><a href="#then方法异步调用" class="headerlink" title="then方法异步调用"></a>then方法异步调用</h2><p>如下面的代码：输入顺序是：<code>1、2、ConardLi</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>resolve</code>是同步执行的，我们必须保证<code>then</code>是异步调用的，我们用<code>settimeout</code>来模拟异步调用（并不能实现微任务和宏任务的执行机制，只是保证异步调用）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> FULFILLED:</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> REJECTED:</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PENDING:</span><br><span class="line">      <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="then方法链式调用"><a href="#then方法链式调用" class="headerlink" title="then方法链式调用"></a>then方法链式调用</h2><p>保证链式调用，即<code>then</code>方法中要返回一个新的<code>promise</code>，并将<code>then</code>方法的返回值进行<code>resolve</code>。</p><blockquote><p>注意：这种实现并不能保证<code>then</code>方法中返回一个新的<code>promise</code>，只能保证链式调用。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected != <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">      <span class="keyword">case</span> FULFILLED:</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">            resolve(x);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> REJECTED:</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">            resolve(x);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PENDING:</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">              resolve(x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">              reject(reason);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">              resolve(x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">              reject(reason);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><p>若上面没有定义<code>reject</code>方法，所有的异常会走向<code>catch</code>方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><p>不管是<code>resolve</code>还是<code>reject</code>都会调用<code>finally</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">       fn();</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><p><code>Promise.resolve</code>用来生成一个直接处于<code>FULFILLED</code>状态的Promise。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h2><p><code>Promise.reject</code>用来生成一个直接处于<code>REJECTED</code>状态的Promise。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h2><p>接受一个<code>promise</code>数组，当所有<code>promise</code>状态<code>resolve</code>后，执行<code>resolve</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve([]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          result[i] = data;</span><br><span class="line">          <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h2><p>接受一个<code>promise</code>数组，当有一个<code>promise</code>状态<code>resolve</code>后，执行<code>resolve</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(data);</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础版本&quot;&gt;&lt;a href=&quot;#基础版本&quot; class=&quot;headerlink&quot; title=&quot;基础版本&quot;&gt;&lt;/a&gt;基础版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设定三个状态 &lt;code&gt;PENDING、FULFILLED、REJECTED&lt;/code&gt; ，只能由&lt;code</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>数组去重、扁平、最值</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E3%80%81%E6%89%81%E5%B9%B3%E3%80%81%E6%9C%80%E5%80%BC/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E3%80%81%E6%89%81%E5%B9%B3%E3%80%81%E6%9C%80%E5%80%BC/</id>
    <published>2021-09-24T06:16:00.437Z</published>
    <updated>2021-09-24T06:16:00.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>开辟一个外部存储空间用于标示元素是否出现过。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function">(<span class="params">array</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> container = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span>  container.hasOwnProperty(item) ? <span class="literal">false</span> : (container[item] = <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="indexOf-filter"><a href="#indexOf-filter" class="headerlink" title="indexOf + filter"></a>indexOf + filter</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> arr.filter(<span class="function">(<span class="params">e,i</span>) =&gt;</span> arr.indexOf(e) === i);</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)];</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>通过比较相邻数字是否重复，将排序后的数组进行去重。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  array.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!i || array[i] != array[pre]) &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="去除重复的值"><a href="#去除重复的值" class="headerlink" title="去除重复的值"></a>去除重复的值</h3><p>不同于上面的去重，这里是只要数字出现了重复次，就将其移除掉。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> filterNonUnique = <span class="function"><span class="params">arr</span> =&gt;</span> arr.filter(<span class="function"><span class="params">i</span> =&gt;</span> </span><br><span class="line">  arr.indexOf(i) === arr.lastIndexOf(i)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flat = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(array[i])) &#123;</span><br><span class="line">      result = result.concat(flat(array[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用reduce简化"><a href="#使用reduce简化" class="headerlink" title="使用reduce简化"></a>使用reduce简化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(</span><br><span class="line">    <span class="function">(<span class="params">target, current</span>) =&gt;</span></span><br><span class="line">      <span class="built_in">Array</span>.isArray(current) ?</span><br><span class="line">        target.concat(flatten(current)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据指定深度扁平数组"><a href="#根据指定深度扁平数组" class="headerlink" title="根据指定深度扁平数组"></a>根据指定深度扁平数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenByDeep</span>(<span class="params">array, deep = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.reduce(</span><br><span class="line">    <span class="function">(<span class="params">target, current</span>) =&gt;</span></span><br><span class="line">      <span class="built_in">Array</span>.isArray(current) &amp;&amp; deep &gt; <span class="number">1</span> ?</span><br><span class="line">        target.concat(flattenByDeep(current, deep - <span class="number">1</span>)) :</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.reduce(<span class="function">(<span class="params">c,n</span>)=&gt;</span><span class="built_in">Math</span>.max(c,n))</span><br></pre></td></tr></table></figure><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><p><code>Math.max</code>参数原本是一组数字，只需要让他可以接收数组即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,array);</span><br><span class="line"><span class="built_in">Math</span>.max(...array);</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现map"><a href="#使用reduce实现map" class="headerlink" title="使用reduce实现map"></a>使用reduce实现map</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToMap = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">    target.push(handler.call(<span class="built_in">this</span>, current, index))</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用reduce实现filter"><a href="#使用reduce实现filter" class="headerlink" title="使用reduce实现filter"></a>使用reduce实现filter</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduceToFilter = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">target, current, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler.call(<span class="built_in">this</span>, current, index)) &#123;</span><br><span class="line">      target.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;去重&quot;&gt;&lt;a href=&quot;#去重&quot; class=&quot;headerlink&quot; title=&quot;去重&quot;&gt;&lt;/a&gt;去重&lt;/h2&gt;&lt;h3 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;O</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-09-24T06:16:00.437Z</published>
    <updated>2021-09-24T06:16:00.437Z</updated>
    
    <content type="html"><![CDATA[<p>文章参考自<a href="https://www.cnblogs.com/echolun/p/7889848.html">JS深拷贝与浅拷贝的区别，实现深拷贝的几种方法</a>，感谢。</p><h1 id="区分深拷贝、浅拷贝"><a href="#区分深拷贝、浅拷贝" class="headerlink" title="区分深拷贝、浅拷贝"></a>区分深拷贝、浅拷贝</h1><p>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</p><ul><li>基本数据类型存储在栈中，比如说以 <code>name1-value1</code> 的形式存储，当复制了一个基本数据，就会在栈中新开辟一个空间进行存储 <code>name2-value2</code>（value1 = value2）。</li><li>引用数据类型在栈中存储形式为 <code>name1-address</code>，其中address存储的是“堆地址”，堆内存中又以 <code>address-value</code> 形式存储，当复制了一个引用数据类型，得到 <code>name2-address</code>，可以看到这里复制的是堆地址，指向的是同一组数据value，修改来修改去都是修改的同一组数据，这就是所谓的浅拷贝。所以为了解决上述的问题，有了深拷贝。<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure><h1 id="简陋深拷贝"><a href="#简陋深拷贝" class="headerlink" title="简陋深拷贝"></a>简陋深拷贝</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归去复制所有层级属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断obj是一个数组还是对象</span></span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="comment">//判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class="line">                <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    b = deepClone(a);</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">//a:[2,2,3,4] b:[1,2,3,4]</span></span><br></pre></td></tr></table></figure><h1 id="SS级深拷贝"><a href="#SS级深拷贝" class="headerlink" title="SS级深拷贝"></a>SS级深拷贝</h1>来自大佬写法：<a href="http://www.conardli.top/blog/article/JS%E8%BF%9B%E9%98%B6/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E6%83%8A%E8%89%B3%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D.html">如何写出一个惊艳面试官的深拷贝</a>，感谢。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> argsTag = <span class="string">&#x27;[object Arguments]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> length = array.length;</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> target;</span><br><span class="line">    <span class="keyword">return</span> target !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">&#x27;object&#x27;</span> || type === <span class="string">&#x27;function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneReg</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">    result.lastIndex = targe.lastIndex;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">    <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">    <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">    <span class="keyword">if</span> (func.prototype) &#123;</span><br><span class="line">        <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">        <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">        <span class="keyword">if</span> (body) &#123;</span><br><span class="line">            <span class="keyword">if</span> (param) &#123;</span><br><span class="line">                <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(funcString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneOtherType</span>(<span class="params">targe, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> boolTag:</span><br><span class="line">        <span class="keyword">case</span> numberTag:</span><br><span class="line">        <span class="keyword">case</span> stringTag:</span><br><span class="line">        <span class="keyword">case</span> errorTag:</span><br><span class="line">        <span class="keyword">case</span> dateTag:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Ctor(targe);</span><br><span class="line">        <span class="keyword">case</span> regexpTag:</span><br><span class="line">            <span class="keyword">return</span> cloneReg(targe);</span><br><span class="line">        <span class="keyword">case</span> symbolTag:</span><br><span class="line">            <span class="keyword">return</span> cloneSymbol(targe);</span><br><span class="line">        <span class="keyword">case</span> funcTag:</span><br><span class="line">            <span class="keyword">return</span> cloneFunction(targe);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆原始类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> type = getType(target);</span><br><span class="line">    <span class="keyword">let</span> cloneTarget;</span><br><span class="line">    <span class="keyword">if</span> (deepTag.includes(type)) &#123;</span><br><span class="line">        cloneTarget = getInit(target, type);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cloneOtherType(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆set</span></span><br><span class="line">    <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">        target.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.add(clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆map</span></span><br><span class="line">    <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">        target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            cloneTarget.set(key, clone(value,map));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆对象和数组</span></span><br><span class="line">    <span class="keyword">const</span> keys = type === arrayTag ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">    forEach(keys || target, <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">            key = value;</span><br><span class="line">        &#125;</span><br><span class="line">        cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章参考自&lt;a href=&quot;https://www.cnblogs.com/echolun/p/7889848.html&quot;&gt;JS深拷贝与浅拷贝的区别，实现深拷贝的几种方法&lt;/a&gt;，感谢。&lt;/p&gt;
&lt;h1 id=&quot;区分深拷贝、浅拷贝&quot;&gt;&lt;a href=&quot;#区分深拷贝、浅拷贝&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2021-09-24T06:16:00.437Z</published>
    <updated>2021-09-24T06:16:00.437Z</updated>
    
    <content type="html"><![CDATA[<ul><li>前言：在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 <h1 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</li></ul><p><code>举个栗子</code></p><p>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如1000ms，然后：</p><ol><li>如果在1000ms内没有再次触发事件，那么就执行函数；</li><li>如果在1000ms内再次触发事件，那么当前的计时清零，重新开始计时。<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3>如果短时间内大量触发同一事件，只会执行一次函数。<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3></li><li>浏览器滚动条位置监听。（如果去写一个函数监听滚动条的位置且不设置防抖，那么这个函数在短时间内就会执行多次，造成不必要的性能消耗）</li><li>页面的resize事件。（你按着Ctrl然后一直滑动鼠标滚轮调整窗口大小就会触发防抖，松开一小段时间就会执行resize函数，窗口缩放才会成功）</li><li>代码编辑器的自动保存。（当你一直在敲键盘的时候就会触发防抖，停下来思考一会儿就会执行自动保存的函数）<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3></li></ol><ul><li>代码记忆关键：防抖重在<code>清零</code>（clearTimeout(timer)）。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防抖（常规）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      f(...args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防抖第一次立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceImmediate</span>(<span class="params">f, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            f(...args);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防抖合并实现（通过传参判断是否需要第一次立即执行）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounceMerge</span>(<span class="params">f, wait, isImmediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            isImmediate &amp;&amp; f(...args);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            !isImmediate &amp;&amp; f(...args);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h1><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。（理解为它有冷却时间）<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3>如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3></li></ul><ol><li>进度条每隔1s更新一次；</li><li>页面的 resize 事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行 dom 渲染（看需求用防抖或者节流，一般用防抖）；</li><li>搜索框 input 事件，例如要支持输入实时搜索可以使用节流（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3></li></ol><ul><li>代码记忆关键：节流重在<code>开关锁</code>（timer = null）。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节流（常规）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            f(...args);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节流第一次立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleImmediate</span>(<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            f(...args);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节流合并实现（通过传参判断是否需要第一次立即执行）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttleMerge</span>(<span class="params">f, wait, isImmediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            isImmediate &amp;&amp; f(...args);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                !isImmediate &amp;&amp; f(...args);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1>这里使用 <code>resize</code> 窗口缩放事件来进行测试，可以在控制台查看结果输出次数是怎样的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnD</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;触发函数防抖&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnT</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;触发函数节流&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// window.addEventListener(&quot;resize&quot;, debounce(fnD, 1000));</span></span><br><span class="line"><span class="comment">// window.addEventListener(&quot;resize&quot;, throttle(fnT, 1000));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// window.addEventListener(&quot;resize&quot;, debounceImmediate(fnD, 1000));</span></span><br><span class="line"><span class="comment">// window.addEventListener(&quot;resize&quot;, throttleImmediate(fnT, 1000));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// window.addEventListener(&quot;resize&quot;, debounceMerge(fnD, 1000, true));</span></span><br><span class="line"><span class="comment">// window.addEventListener(&quot;resize&quot;, throttleMerge(fnT, 1000, false));</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;前言：在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 &lt;h</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
    <category term="性能优化" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><blockquote><p>通俗易懂的解释：用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>判断当前函数传入的参数是否大于或等于<code>fn</code>需要参数的数量，如果是，直接执行<code>fn</code></li><li>如果传入参数数量不够，返回一个闭包，暂存传入的参数，并重新返回<code>currying</code>函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> currying(fn, ...args, ...args2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来一个简单的实例验证一下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curryingFun = currying(fun)</span><br><span class="line">curryingFun(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);  <span class="comment">// 1 2 3 </span></span><br><span class="line">curryingFun(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>);  <span class="comment">// 1 2 3 </span></span><br><span class="line">curryingFun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 1 2 3 </span></span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">protocol, domain, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> protocol + <span class="string">&quot;://&quot;</span> + domain + <span class="string">&quot;/&quot;</span> + path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> page1 = getUrl(<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;www.conardli.top&#x27;</span>, <span class="string">&#x27;page1.html&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> page2 = getUrl(<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;www.conardli.top&#x27;</span>, <span class="string">&#x27;page2.html&#x27;</span>);</span><br></pre></td></tr></table></figure><p>我们使用<code>currying</code>来简化它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> conardliSite = currying(simpleURL)(<span class="string">&#x27;http&#x27;</span>, <span class="string">&#x27;www.conardli.top&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> page1 = conardliSite(<span class="string">&#x27;page1.html&#x27;</span>);    </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<p>在合适的时候才创建对像，并且只创建唯一的一个。</p><p>创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p><p>使用闭包实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = Singleton.getInstance(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance(<span class="string">&#x27;ConardLi2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a===b);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在合适的时候才创建对像，并且只创建唯一的一个。&lt;/p&gt;
&lt;p&gt;创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。&lt;/p&gt;
&lt;p&gt;使用闭包实现：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载、异步加载</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="监听图片高度"><a href="#监听图片高度" class="headerlink" title="监听图片高度"></a>监听图片高度</h2><p>图片，用一个其他属性存储真正的图片地址：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/09/09/16/05/forest-931706_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/08/01/00/08/pier-407252_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2014/12/15/17/16/pier-569314_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2010/12/13/10/09/abstract-2384_1280.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;https://cdn.pixabay.com/photo/2015/10/24/11/09/drop-of-water-1004250_1280.jpg&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过图片<code>offsetTop</code>和<code>window</code>的<code>innerHeight</code>，<code>scrollTop</code>判断图片是否位于可视区域。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line">lazyload(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></span><br><span class="line"><span class="comment">// 节流函数，保证每200ms触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">event, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(lazyload, <span class="number">200</span>))</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123; <span class="comment">//监听页面滚动事件</span></span><br><span class="line">  <span class="keyword">var</span> seeHeight = <span class="built_in">window</span>.innerHeight; <span class="comment">//可见区域高度</span></span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = n; i &lt; img.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(img[i].offsetTop, seeHeight, scrollTop);</span><br><span class="line">    <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</span><br><span class="line">      <span class="keyword">if</span> (img[i].getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">        img[i].src = img[i].getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      n = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><blockquote><p>IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。</p></blockquote><p><code>Intersection Observer</code>可以不用监听<code>scroll</code>事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (IntersectionObserver) &#123;</span><br><span class="line">  <span class="keyword">let</span> lazyImageObserver = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function">(<span class="params">entry, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> lazyImage = entry.target;</span><br><span class="line">      <span class="comment">// 如果元素可见            </span></span><br><span class="line">      <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyImage.getAttribute(<span class="string">&quot;src&quot;</span>) == <span class="string">&quot;loading.gif&quot;</span>) &#123;</span><br><span class="line">          lazyImage.src = lazyImage.getAttribute(<span class="string">&quot;data-src&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; img.length; i++) &#123;</span><br><span class="line">    lazyImageObserver.observe(img[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;监听图片高度&quot;&gt;&lt;a href=&quot;#监听图片高度&quot; class=&quot;headerlink&quot; title=&quot;监听图片高度&quot;&gt;&lt;/a&gt;监听图片高度&lt;/h2&gt;&lt;p&gt;图片，用一个其他属性存储真正的图片地址：&lt;/p&gt;
&lt;figure class=&quot;highlight html</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>异步循环打印</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E5%BC%82%E6%AD%A5%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E5%BC%82%E6%AD%A5%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>promise + async await</code>实现异步循环打印</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sleep = <span class="function"><span class="keyword">function</span> (<span class="params">time, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(i);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> sleep(<span class="number">1000</span>, i);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;code&gt;promise + async await&lt;/code&gt;实现异步循环打印&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span c</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>手动实现call、apply、bind</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E3%80%81bind/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E3%80%81bind/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模拟实现call"><a href="#模拟实现call" class="headerlink" title="模拟实现call"></a>模拟实现call</h2><ul><li>1.判断当前<code>this</code>是否为函数，防止<code> Function.prototype.myCall()</code> 直接调用</li><li>2.<code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>3.为<code>context</code> 创建一个 <code>Symbol</code>（保证不会重名）属性，将当前函数赋值给这个属性</li><li>4.处理参数，传入第一个参数后的其余参数</li><li>4.调用函数后即删除该<code>Symbol</code>属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟实现apply"><a href="#模拟实现apply" class="headerlink" title="模拟实现apply"></a>模拟实现apply</h2><p><code>apply</code>实现类似<code>call</code>，参数为数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span>, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(args)) &#123;</span><br><span class="line">    result = context[fn](...args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context[fn]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模拟实现bind"><a href="#模拟实现bind" class="headerlink" title="模拟实现bind"></a>模拟实现bind</h2><ul><li>1.处理参数，返回一个闭包</li><li>2.判断是否为构造函数调用，如果是则使用<code>new</code>调用当前函数</li><li>3.如果不是，使用<code>apply</code>，将<code>context</code>和处理好的参数传入</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context,...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否用于构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args1, ...args2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args1.concat(args2))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>获取函数中的参数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取argument对象 类数组对象 不能调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数数组  可以调用数组方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;获取参数数组  可以调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除第一个参数的剩余参数数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;获取argument对象 类数组对象 不能调用数组方法&#x27;</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透传参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">  fn(...args);</span><br><span class="line">  fn(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;透传&#x27;</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">test4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模拟实现call&quot;&gt;&lt;a href=&quot;#模拟实现call&quot; class=&quot;headerlink&quot; title=&quot;模拟实现call&quot;&gt;&lt;/a&gt;模拟实现call&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1.判断当前&lt;code&gt;this&lt;/code&gt;是否为函数，防止&lt;code&gt; Fu</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>实现instanceof</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0instanceof/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0instanceof/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>判断<code>Object</code>的prototype是否在<code>a</code>的原型链上。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> proto = target.__proto__;</span><br><span class="line">  <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin.prototype === proto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> myInstanceof(proto, origin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>数组乱序-洗牌算法</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<p>从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disorder</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = array.length;</span><br><span class="line">  <span class="keyword">let</span> current = length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> random;</span><br><span class="line">  <span class="keyword">while</span> (current &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    random = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random());</span><br><span class="line">    [array[current], array[random]] = [array[random], array[current]];</span><br><span class="line">    current--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;func</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>实现JSONP</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0JSONP/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0JSONP/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1.将传入的data数据转化为url字符串形式</li><li>2.处理url中的回调函数</li><li>3.创建一个script标签并插入到页面中 </li><li>4.挂载回调函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>,<span class="built_in">document</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> jsonp = <span class="function"><span class="keyword">function</span> (<span class="params">url,data,callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.将传入的data数据转化为url字符串形式</span></span><br><span class="line">        <span class="comment">// &#123;id:1,name:&#x27;jack&#x27;&#125; =&gt; id=1&amp;name=jack</span></span><br><span class="line">        <span class="keyword">var</span> dataString = url.indexof(<span class="string">&#x27;?&#x27;</span>) == -<span class="number">1</span>? <span class="string">&#x27;?&#x27;</span>: <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">            dataString += key + <span class="string">&#x27;=&#x27;</span> + data[key] + <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 处理url中的回调函数</span></span><br><span class="line">        <span class="comment">// cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span></span><br><span class="line">        <span class="keyword">var</span> cbFuncName = <span class="string">&#x27;my_json_cb_&#x27;</span> + <span class="built_in">Math</span>.random().toString().replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        dataString += <span class="string">&#x27;callback=&#x27;</span> + cbFuncName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建一个script标签并插入到页面中</span></span><br><span class="line">        <span class="keyword">var</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        scriptEle.src = url + dataString;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.挂载回调函数</span></span><br><span class="line">        <span class="built_in">window</span>[cbFuncName] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            <span class="comment">// 处理完回调函数的数据之后，删除jsonp的script标签</span></span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.$jsonp = jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;1.将传入的data数据转化为url字符串形式&lt;/li&gt;
&lt;li&gt;2.处理url中的回调函数&lt;/li&gt;
&lt;li&gt;3.创建一个script标签并插入到页面中 &lt;/li&gt;
&lt;li&gt;4.挂载回调函数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>八大排序算法</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-24T06:16:00.436Z</published>
    <updated>2021-09-24T06:16:00.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tva2.sinaimg.cn/large/00897VxHly8gpqus2wttlj30qu0gcdjr.jpg" alt="八大排序算法"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端， 最终达到完全有序。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//①双重 for 循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arrLength = arr.length;</span><br><span class="line">    <span class="comment">//如果arr不是数组或arr的长度小于等于1</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || arrLength &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLength; i++) &#123;</span><br><span class="line">        <span class="comment">//用于标记内层是否发生交换元素的行为</span></span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//内层循环优化：对于后面已经排序好的元素没有必要遍历，需要减去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arrLength - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//交换元素</span></span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 外层循环优化：如果内层循环已经没有交换元素了，那就可以直接结束外层循环了</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//② while + for 循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//记录最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">let</span> lastIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//当最后一个交换的元素为第一个时，说明后面已全部排序完毕</span></span><br><span class="line">    <span class="keyword">while</span> (lastIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span>, k = lastIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//设置最后一次交换元素的位置</span></span><br><span class="line">                lastIndex = j;</span><br><span class="line">                [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序有两种优化方式。</p><p>一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。 因此我们**不需要再执行之后的外层循环，此时可以直接结束。</p><p>另一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下一轮循环中无需再去比较。</p><p>优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。</p><p>平均时间复杂度为 O(n²)，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1)，稳定排序。</p><p>详细资料可以参考： <a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a> <a href="http://bubkoo.com/2014/01/15/sort-algorithm/shaker-sort/">《常见排序算法 - 鸡尾酒排序 》</a> <a href="https://juejin.im/post/5b72f0caf265da282809f3b5#heading-1">《前端笔试&amp;面试爬坑系列—算法》</a> <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41">《前端面试之道》</a></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。</p><p>在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果这不是一个数组或者该数组的长度小于等于1，无需进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录最小元素的下标</span></span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//如果当前元素比“最小索引”元素小，则更新最小索引</span></span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换元素</span></span><br><span class="line">        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序不管初始序列是否有序，时间复杂度都为 O(n²)。</p><p>平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，不稳定排序。</p><p>详细资料可以参考： <a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p><p>插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边， 继续接，可能是中间数，就插在中间….依次。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环从 1 开始，0 位置默认已经排好序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = array[i];</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在当前已排序序列中作比较，如果比需要排序的元素大，就依次往后移动位置</span></span><br><span class="line">        <span class="keyword">while</span> (array[j - <span class="number">1</span>] &gt; temp &amp;&amp; j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将找到的位置插入元素</span></span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当排序序列为已排序序列时，为最好的时间复杂度 O(n)。</p><p>插入排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。</p><p>详细资料可以参考： <a href="https://www.cnblogs.com/chengxiao/p/6103002.html">《图解排序算法(一)》</a></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元素越来越多，当增量减至 1 时，整个数组恰被分成一组，算法便终止。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一层确定增量的大小，每次增量的大小减半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> gap = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>); gap &gt;= <span class="number">1</span>; gap = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">//对每个分组使用插入排序，相当于将插入排序的 1 换成了 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = array[i];</span><br><span class="line">            <span class="keyword">let</span> j = i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (array[j - gap] &gt; temp &amp;&amp; j &gt;= gap) &#123;</span><br><span class="line">                array[j] = array[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行 基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一 次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。</p><p>简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序， 所以排序速度也很快。</p><p>希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。</p><p>插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化， 所以希尔排序是一个不稳定的排序。</p><p>希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不稳定排序。</p><p>详细资料可以参考： <a href="https://www.cnblogs.com/chengxiao/p/6104371.html">《图解排序算法(二)之希尔排序》</a> <a href="https://blog.csdn.net/u013630349/article/details/48250109">《数据结构基础 希尔排序 之 算法复杂度浅析》</a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后将数组排序合并，最终合并为排序好的数组。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>),      <span class="comment">//找到中间索引值</span></span><br><span class="line">        left = array.slice(<span class="number">0</span>, mid),       <span class="comment">//截取左半部分</span></span><br><span class="line">        right = array.slice(mid, length); <span class="comment">//截取右半部分</span></span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right)); <span class="comment">//递归分解后，进行排序合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">leftArray, rightArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">        leftLength = leftArray.length,</span><br><span class="line">        rightLength = rightArray.length,</span><br><span class="line">        il = <span class="number">0</span>,</span><br><span class="line">        ir = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完为止</span></span><br><span class="line">    <span class="keyword">while</span> (il &lt; leftLength &amp;&amp; ir &lt; rightLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArray[il] &lt; rightArray[ir]) &#123;</span><br><span class="line">            result.push(leftArray[il++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(rightArray[ir++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果左边数组还有剩余，则把剩余的元素全部加入到结果数组中</span></span><br><span class="line">    <span class="keyword">while</span> (il &lt; leftLength) &#123;</span><br><span class="line">        result.push(leftArray[il++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边数组还有剩余</span></span><br><span class="line">    <span class="keyword">while</span> (ir &lt; rightLength) &#123;</span><br><span class="line">        result.push(rightArray[ir++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每 一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。</p><p>归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归并排序的空间复杂度为 O(n)。</p><p>归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。</p><p>详细资料可以参考： <a href="https://www.cnblogs.com/chengxiao/p/6194356.html">《图解排序算法(四)之归并排序》</a> <a href="https://www.zhihu.com/question/27274006">《归并排序的空间复杂度？》</a></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span> || start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数组划分成两部分，并返回右部分的第一个元素的索引值</span></span><br><span class="line">    <span class="keyword">let</span> index = partition(array, start, end); </span><br><span class="line">    </span><br><span class="line">    quickSort(array, start, index - <span class="number">1</span>); <span class="comment">//递归排序左半部分</span></span><br><span class="line">    quickSort(array, index + <span class="number">1</span>, end); <span class="comment">//递归排序右半部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//取第一个值为枢纽值，获取枢纽值的大小</span></span><br><span class="line">    <span class="keyword">let</span> pivot = array[start];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当 start 等于 end 指针时结束循环</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="comment">//从后往前找，找一个小于等于枢纽值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (array[end] &gt;= pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将比枢纽值小或者相等的值交换到 start 位置</span></span><br><span class="line">        array[start] = array[end];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从前往后找，找一个大于枢纽值的元素（这里换成array[start + 1]也行吗？）</span></span><br><span class="line">        <span class="keyword">while</span> (array[start] &lt; pivot &amp;&amp; start &lt; end) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将比枢纽值大的值交换到 end 位置，进入下一次循环</span></span><br><span class="line">        array[end] = array[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将枢纽值交换到中间点（这里也可以是 end，因为 start = end）</span></span><br><span class="line">    array[start] = pivot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回中间索引值（这里也可以是 end，因为 start = end）</span></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一种方法是填空法，首先将第一个位置的数作为枢纽值，然后 end 指针向前移动，当遇到比枢纽值小的值或者 end 值 等于 start 值的时候停止，然后将这个值填入 start 的位置，然后 start 指针向后移动，当遇到比枢纽值大的值或者 start 值等于 end 值的时候停止，然后将这个值填入 end 的位置。反复循环这个过程，直到 start 的值等于 end 的 值为止。将一开始保留的枢纽值填入这个位置，此时枢纽值左边的值都比枢纽值小，枢纽值右边的值都比枢纽值大。然后在递 归左右两边的的序列。</p><p>当每次换分的结果为含 ⌊n/2⌋和 ⌈n/2⌉−1 个元素时，最好情况发生，此时递归的次数为 logn，然后每次划分的时间复杂 度为 O(n)，所以最优的时间复杂度为 O(nlogn)。一般来说只要每次换分都是常比例的划分，时间复杂度都为 O(nlogn)。</p><p>当每次换分的结果为 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为 O(n)，递归的次数为 n-1，所以最坏 的时间复杂度为 O(n²)。所以当排序序列有序的时候，快速排序有可能被转换为冒泡排序。</p><p>快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。</p><p>快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(logn) ，不稳定排序。</p><p>详细资料可以参考： <a href="https://www.cnblogs.com/chengxiao/p/6262208.html">《图解排序算法(五)之快速排序——三数取中法》</a> <a href="https://segmentfault.com/a/1190000004410119#articleHeader2">《关于快速排序的四种写法》</a> <a href="https://harttle.land/2015/09/27/quick-sort.html">《快速排序的时间和空间复杂度》</a> <a href="https://blog.csdn.net/weshjiness/article/details/8660583">《快速排序最好，最坏，平均复杂度分析》</a> <a href="https://blog.csdn.net/qq_33758761/article/details/76782610">《快速排序算法的递归深度》</a></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行 交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行， 便能得到一个有序序列了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将传入的数组建立为大顶堆</span></span><br><span class="line">    buildMaxHeap(array);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">//将剩下的元素重新构建为大顶堆</span></span><br><span class="line">        adjustMaxHeap(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustMaxHeap</span>(<span class="params">array, index, heapSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> iMax,</span><br><span class="line">        iLeft,</span><br><span class="line">        iRight;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        iMax = index; <span class="comment">//保存最大值的索引</span></span><br><span class="line">        iLeft = <span class="number">2</span> * index + <span class="number">1</span>; <span class="comment">//获取左子元素的索引</span></span><br><span class="line">        iRight = <span class="number">2</span> * index + <span class="number">2</span>; <span class="comment">//获取右子元素的索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果左子元素存在，且左子元素大于最大值，则更新最大值索引</span></span><br><span class="line">        <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) &#123;</span><br><span class="line">            iMax = iLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果右子元素存在，且左子元素大于最大值，则更新最大值索引</span></span><br><span class="line">        <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123;</span><br><span class="line">            iMax = iRight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果最大元素被更新了，则交换位置，使父节点大于它的子节点，同时将索引值更新为被替换的值，继续检查它的子树</span></span><br><span class="line">        <span class="keyword">if</span> (iMax !== index) &#123;</span><br><span class="line">            swap(array, index, iMax);</span><br><span class="line">            index = iMax;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//如果未被更新，说明该子树满足大顶堆的要求，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length,</span><br><span class="line">        iParent = <span class="built_in">parseInt</span>(length &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; <span class="comment">//获取最后一个非叶子节点的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjustMaxHeap(array, i, length); <span class="comment">//循环调整每一颗子树，使其满足大顶堆的要求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换数组中两个元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在 不管什么情况下都是 O(nlogn)。</p><p>堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不稳定排序。</p><p>详细资料可以参考： <a href="https://www.cnblogs.com/chengxiao/p/6129630.html">《图解排序算法(三)之堆排序》</a> <a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">《常见排序算法 - 堆排序 (Heap Sort)》</a> <a href="https://www.zhihu.com/question/20729324">《堆排序中建堆过程时间复杂度O(n)怎么来的？》</a> <a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44258297">《排序算法之 堆排序 及其时间复杂度和空间复杂度》</a> <a href="https://blog.csdn.net/hrn1216/article/details/51465270">《最小堆 构建、插入、删除的过程图解》</a></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = array.length;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span>  bucket = [],</span><br><span class="line">        max = array[<span class="number">0</span>],</span><br><span class="line">        loop;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//确定排序数组中的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确定最大值的位数</span></span><br><span class="line">    loop = (max + <span class="string">&#x27;&#x27;</span>).length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bucket[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> str = array[j] + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (str.length &gt;= i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取当前位的值，作为插入的索引</span></span><br><span class="line">                <span class="keyword">let</span> k = <span class="built_in">parseInt</span>(str[str.length - <span class="number">1</span> - i]);</span><br><span class="line">                bucket[k].push(array[j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理位数不够的情况，高位默认为 0</span></span><br><span class="line">                bucket[<span class="number">0</span>].push(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空旧的数组</span></span><br><span class="line">        array.splice(<span class="number">0</span>, length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用桶重新初始化数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> t = bucket[i].length;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">                array.push(bucket[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[i] = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定排序。</p><p>详细资料可以参考： <a href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/">《常见排序算法 - 基数排序》</a> <a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44594415">《排序算法之 基数排序 及其时间复杂度和空间复杂度》</a></p><p>算法总结可以参考： <a href="https://blog.csdn.net/zolalad/article/details/11848739">《算法的时间复杂度和空间复杂度-总结》</a> <a href="https://www.cnblogs.com/onepixel/p/7674659.html">《十大经典排序算法（动图演示）》</a> <a href="https://blog.csdn.net/wangiijing/article/details/51485119">《各类排序算法的对比及实现》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://tva2.sinaimg.cn/large/00897VxHly8gpqus2wttlj30qu0gcdjr.jpg&quot; alt=&quot;八大排序算法&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;head</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="排序" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS 布局</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/CSS%E5%B8%83%E5%B1%80/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/CSS%E5%B8%83%E5%B1%80/</id>
    <published>2021-09-24T06:16:00.435Z</published>
    <updated>2021-09-24T06:16:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考自<a href="https://juejin.cn/post/6844903710070407182#heading-12">几种常见的CSS布局</a>，感谢。</p><h1 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h1><h3 id="1-header-content和footer等宽的单列布局"><a href="#1-header-content和footer等宽的单列布局" class="headerlink" title="1. header,content和footer等宽的单列布局"></a>1. header,content和footer等宽的单列布局</h3><p><img src="https://tva2.sinaimg.cn/large/00897VxHly8gpq40mekbcj31ha0qbwex.jpg" alt="单列布局-1"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">545px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-header与footer等宽，content略窄的单列布局"><a href="#2-header与footer等宽，content略窄的单列布局" class="headerlink" title="2. header与footer等宽，content略窄的单列布局"></a>2. header与footer等宽，content略窄的单列布局</h3><p><img src="https://tva3.sinaimg.cn/large/00897VxHly8gpq40y23iej31hc0q8q3e.jpg" alt="单列布局-2"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: darkgray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">545px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h1><h3 id="1-table布局"><a href="#1-table布局" class="headerlink" title="1. table布局"></a>1. table布局</h3><p><img src="https://tva4.sinaimg.cn/large/00897VxHly8gpq4unt8daj30s70hndfu.jpg" alt="table布局-1"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border-collapse</span>: collapse; <span class="comment">/*合并表格边框**/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: burlywood;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-table-class布局"><a href="#2-table-class布局" class="headerlink" title="2. table class布局"></a>2. table class布局</h3><p>布局效果图和上方的table布局一样，相当于用div模拟出了一个table。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;table_row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left table_cell&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right table_cell&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.table</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table_row</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table_cell</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: burlywood;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两列自适应布局"><a href="#两列自适应布局" class="headerlink" title="两列自适应布局"></a>两列自适应布局</h1><p>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式。<br><img src="https://tva2.sinaimg.cn/large/00897VxHly8gpq9640wuqj31gz074glk.jpg" alt="两列自适应布局"></p><h3 id="1-float-BFC-overflow-hidden"><a href="#1-float-BFC-overflow-hidden" class="headerlink" title="1. float + BFC(overflow: hidden)"></a>1. float + BFC(overflow: hidden)</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-absolute-margin-方式"><a href="#2-absolute-margin-方式" class="headerlink" title="2. absolute + margin 方式"></a>2. absolute + margin 方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-float-margin-方式"><a href="#3-float-margin-方式" class="headerlink" title="3. float + margin 方式"></a>3. float + margin 方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-float-负margin-方式"><a href="#4-float-负margin-方式" class="headerlink" title="4. float + 负margin 方式"></a>4. float + 负margin 方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-flex-方式"><a href="#5-flex-方式" class="headerlink" title="5. flex 方式"></a>5. flex 方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;                <span class="comment">/*容器的高度是被left模块撑起来的*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: auto;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-grid-方式"><a href="#6-grid-方式" class="headerlink" title="6. grid 方式"></a>6. grid 方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">200px</span> auto;</span><br><span class="line">    grid-template-rows: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h1><p><img src="https://tva4.sinaimg.cn/large/00897VxHly8gpqdf307ttj31gz0anq2y.jpg" alt="三栏布局"></p><ul><li><code>特征</code>：中间列自适应宽度，旁边两侧固定宽度</li><li><code>种类</code>：圣杯布局和双飞翼布局</li><li><code>差异</code>：圣杯布局通过父容器的内边距来实现各列的间隙；双飞翼布局通过新建的div的外边距隔离各列<h3 id="1-圣杯布局"><a href="#1-圣杯布局" class="headerlink" title="1. 圣杯布局"></a>1. 圣杯布局</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.center</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-双飞翼布局"><a href="#2-双飞翼布局" class="headerlink" title="2. 双飞翼布局"></a>2. 双飞翼布局</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.container</span>, <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-flex-实现三栏布局"><a href="#3-flex-实现三栏布局" class="headerlink" title="3. flex 实现三栏布局"></a>3. flex 实现三栏布局</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: -<span class="number">1</span>;                   <span class="comment">/*使left能排在最前面*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: auto;                  <span class="comment">/*自动填充剩余空间*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文参考自&lt;a href=&quot;https://juejin.cn/post/6844903710070407182#heading-12&quot;&gt;几种常见的CSS布局&lt;/a&gt;，感谢。&lt;/p&gt;
&lt;h1 id=&quot;单列布局&quot;&gt;&lt;a href=&quot;#单列布局&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/css/"/>
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
  </entry>
  
  <entry>
    <title>EventEmitter</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/EventEmitter/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/EventEmitter/</id>
    <published>2021-09-24T06:16:00.435Z</published>
    <updated>2021-09-24T06:16:00.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><img src="http://img.blog.csdn.net/20161126191512446" alt="image"></p><p>这就类似我们在微信平台订阅了公众号 , 当它有新的文章发表后，就会推送给我们所有订阅的人。</p><p>我们作为订阅者不必每次都去查看这个公众号有没有新文章发布，公众号作为发布者会在合适时间通知我们。</p><p>我们与公众号之间不再强耦合在一起。公众号不关心谁订阅了它， 不管你是男是女还是宠物狗，它只需要定时向所有订阅者发布消息即可。</p><h3 id="观察者模式的优点"><a href="#观察者模式的优点" class="headerlink" title="观察者模式的优点"></a>观察者模式的优点</h3><ul><li>可以广泛应用于异步编程，它可以代替我们传统的回调函数 </li><li>我们不需要关注对象在异步执行阶段的内部状态，我们只关心事件完成的时间点</li><li>取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。</li></ul><p>虽然不知道彼此的细节，但不影响相互通信。更重要的是，其中一个对象改变不会影响另一个对象。</p><h2 id="Nodejs的EventEmitter"><a href="#Nodejs的EventEmitter" class="headerlink" title="Nodejs的EventEmitter"></a>Nodejs的EventEmitter</h2><p><code>Nodejs</code>的<code>EventEmitter</code>就是观察者模式的典型实现，<code>Nodejs</code>的<code>events</code>模块只提供了一个对象： <code>events.EventEmitter``。EventEmitter</code> 的核心就是事件触发与事件监听器功能的封装。</p><blockquote><p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p></blockquote><h3 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h3><p><strong>addListener(event, listener)</strong></p><p>为指定事件添加一个监听器，默认添加到监听器数组的尾部。</p><p><strong>removeListener(event, listener)</strong></p><p>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p><p><strong>setMaxListeners(n)</strong></p><p>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p><p><strong>once(event, listener)</strong></p><p>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p><p><strong>emit(event, [arg1], [arg2], […])</strong></p><p>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 <code>true</code>，否则返回 <code>false</code>。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener1 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;监听器 listener2 执行。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">&#x27;connection&#x27;</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，调用一次，处理函数为 listener2</span></span><br><span class="line">eventEmitter.once(<span class="string">&#x27;connection&#x27;</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="手动实现EventEmitter"><a href="#手动实现EventEmitter" class="headerlink" title="手动实现EventEmitter"></a>手动实现EventEmitter</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._maxListeners = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件</span></span><br><span class="line"><span class="comment">// prepend为true表示向事件队列头部添加事件</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, prepend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>._events) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._events[type]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      <span class="built_in">this</span>._events[type].unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._events[type].push(listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._events[type] = [listener];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除某个事件</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>._events[type]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._events[type] = <span class="built_in">this</span>._events[type].filter(<span class="function"><span class="params">e</span> =&gt;</span> e !== listener &amp;&amp; e.origin !== listener)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向事件队列添加事件，只执行一次</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> only = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    listener.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="built_in">this</span>.removeListener(type, listener);</span><br><span class="line">  &#125;</span><br><span class="line">  only.origin = listener;</span><br><span class="line">  <span class="built_in">this</span>.addListener(type, only);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行某类事件</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>._events[type])) &#123;</span><br><span class="line">    <span class="built_in">this</span>._events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大事件监听个数</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.maxListeners = count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onceListener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我只能被执行一次&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是一个listener&#x27;</span>, args, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emitter.once(<span class="string">&#x27;click&#x27;</span>, onceListener);</span><br><span class="line">emitter.addListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line"></span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line">emitter.removeListener(<span class="string">&#x27;click&#x27;</span>, listener);</span><br><span class="line">emitter.emit(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="JavaScript自定义事件"><a href="#JavaScript自定义事件" class="headerlink" title="JavaScript自定义事件"></a>JavaScript自定义事件</h2><p><code>DOM</code>也提供了类似上面<code>EventEmitter</code>的<code>API</code>，基本使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建事件</span></span><br><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">&quot;myEvent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、注册事件监听器</span></span><br><span class="line">elem.addEventListener(<span class="string">&quot;myEvent&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、触发事件</span></span><br><span class="line">elem.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161126191512446&quot; alt=</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
    <category term="Nodejs" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Promise实现Ajax</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/Promise%E5%AE%9E%E7%8E%B0Ajax/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/Promise%E5%AE%9E%E7%8E%B0Ajax/</id>
    <published>2021-09-24T06:16:00.435Z</published>
    <updated>2021-09-24T06:16:00.435Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; getJSON = &lt;span class=&quot;f</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
    <category term="Promise" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/promise/"/>
    
    <category term="Ajax" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>JS的6种继承方式</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/JS%E7%9A%846%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/JS%E7%9A%846%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</id>
    <published>2021-09-24T06:16:00.435Z</published>
    <updated>2021-09-24T06:16:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考自<a href="https://www.cnblogs.com/ranyonsue/p/11201730.html">js继承的6种方式</a>，感谢。</p><p>想要继承，就必须先有父类（继承谁，提供谁的属性）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//给构造函数添加了参数</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//给构造函数添加了原型属性</span></span><br><span class="line">Person.prototype.age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Per</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;ker&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新实例的原型 = 父类的实例</span></span><br><span class="line">Per.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> per1 = <span class="keyword">new</span> Per();</span><br><span class="line"><span class="built_in">console</span>.log(per1.age); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//instanceof 判断元素是否在另一个元素的原型链上</span></span><br><span class="line"><span class="comment">//per1 继承了Person的属性，返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(per1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>重点：让新实例的原型等于父类的实例。</li><li>特点：实例可继承的属性有：<ol><li>实例的构造函数的属性；</li><li>父类构造函数的属性；</li><li>父类原型的属性（新实例不会继承父类实例的属性）。</li></ol></li><li>缺点：<ol><li>新实例无法向父类构造函数传参；</li><li>继承单一；</li><li>所有新实例都会共享父类实例的属性（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改）。<h1 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Con</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>, <span class="string">&quot;jer&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> con1 = <span class="keyword">new</span> Con();</span><br><span class="line"><span class="built_in">console</span>.log(con1.name); <span class="comment">//&quot;jer&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(con1.age); <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(con1 <span class="keyword">instanceof</span> Person); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol></li><li>重点：用<code>.call()</code>和<code>.apply()</code>将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））。</li><li>特点：<ol><li>只继承了父类构造函数的属性，没有继承父类原型的属性；</li><li>解决了原型链继承缺点1、2、3；</li><li>可以继承多个构造函数属性（call多个）；</li><li>在子实例中可向父实例传参。</li></ol></li><li>缺点：<ol><li>只能继承父类构造函数的属性；</li><li>无法实现构造函数的复用（每次用每次都要重新调用）；</li><li>每个新实例都有父类构造函数的副本，臃肿。<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//借用构造函数模式</span></span><br><span class="line">    Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType(<span class="string">&quot;gar&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub.name); <span class="comment">//&quot;gar&quot; （继承了构造函数属性）</span></span><br><span class="line"><span class="built_in">console</span>.log(sub.age); <span class="comment">//10 （继承了父类原型的属性）</span></span><br></pre></td></tr></table></figure></li></ol></li><li>重点：结合了两种模式的优点，传参和复用。</li><li>特点：<ol><li>可以继承父类原型上的属性，可以传参，可复用；</li><li>每个新实例引入的构造函数属性是私有的。</li></ol></li><li>缺点：<ol><li>调用了两次父类构造函数（耗内存）；</li><li>子类的构造函数会代替原型上的那个父类构造函数。</li></ol></li></ul><h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">content</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">//先封装一个函数容器，用来输出对象和承载继承的原型</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj; <span class="comment">//继承了传入的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">//返回函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Person(); <span class="comment">//拿到父类的实例</span></span><br><span class="line"><span class="keyword">var</span> sup1 = content(sup);</span><br><span class="line"><span class="built_in">console</span>.log(sup1.age); <span class="comment">//10 （继承了父类函数的属性）</span></span><br></pre></td></tr></table></figure><ul><li>重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。<code>Object.create()</code>就是这个原理。</li><li>特点：类似于复制一个对象，用函数来包装。</li><li>缺点：<ol><li>所有实例都会继承原型上的属性；</li><li>无法实现复用（新实例属性都是后面添加的）。<h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">content</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj; <span class="comment">//继承了传入的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">//返回函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//以上是原型式继承，给原型式继承再套个壳子传递参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subobject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sub = content(obj);</span><br><span class="line">    sub.name = <span class="string">&quot;gar&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup2 = subobject(sup);</span><br><span class="line"><span class="comment">//这个函数经过声明之后就成了可增添属性的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> subobject); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sup2); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(sup2.name); <span class="comment">//&quot;gar&quot; （返回了一个sub对象，继承了sub的属性）</span></span><br></pre></td></tr></table></figure></li></ol></li><li>重点：就是给原型式继承外面套了个壳子。</li><li>特点：没有创建自定义类型，因为只是套了个壳子返回对象，这个函数顺理成章就成了创建的新对象。</li><li>缺点：没用到原型，无法复用。<h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1></li><li>寄生：在函数内返回对象然后调用。</li><li>组合：<ol><li>函数的原型等于另一个实例；</li><li>在函数中用<code>apply</code>或者<code>call</code>引入另一个构造函数，可传参。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">content</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//content就是F实例的另一种表示法</span></span><br><span class="line"><span class="keyword">var</span> con = content(Person.prototype);</span><br><span class="line"><span class="comment">//con实例（F实例）的原型继承了父类函数的原型</span></span><br><span class="line"><span class="comment">//上述更像是原型链继承，只不过只继承了原型属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//组合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>); <span class="comment">//这个继承了父类构造函数的属性</span></span><br><span class="line">&#125; <span class="comment">//解决了组合式两次调用构造函数属性的缺点</span></span><br><span class="line"><span class="comment">//重点</span></span><br><span class="line">Sub.prototype = con; <span class="comment">//继承了con实例</span></span><br><span class="line">con.constructor = Sub; <span class="comment">//一定要修复实例</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="comment">//Sub的实例就继承了构造函数属性，父类实例，con的函数属性</span></span><br><span class="line"><span class="built_in">console</span>.log(sub1.age); <span class="comment">//10</span></span><br></pre></td></tr></table></figure></li></ol></li><li>重点：修复了组合继承的问题。<h1 id="手动实现ES5-继承"><a href="#手动实现ES5-继承" class="headerlink" title="手动实现ES5 继承"></a>手动实现ES5 继承</h1>以下内容来自<a href="https://github.com/ConardLi/awesome-coding-js/tree/master/JavaScript">ConardLi/awesome-coding-js/JavaScript</a>，感谢。</li></ul><p>有下面两个类，下面实现 <code>Man</code> 继承 <code>People</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;prople&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">People.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;吃东西啦&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>将父类指向子类的原型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Man.prototype = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure><p>缺点：原型是所有子类实例共享的，改变一个其他也会改变。</p><h3 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h3><p>在子类构造函数中调用父类构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。</p><h3 id="组合继承-1"><a href="#组合继承-1" class="headerlink" title="组合继承"></a>组合继承</h3><p>使用构造继承继承父类参数，使用原型继承继承父类函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype = People.prototype;</span><br></pre></td></tr></table></figure><p>缺点：父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</p><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>在组合继承的基础上，子类继承一个由父类原型生成的空对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype = <span class="built_in">Object</span>.create(People.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: Man</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="inherits函数"><a href="#inherits函数" class="headerlink" title="inherits函数"></a>inherits函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">ctor, superCtor</span>) </span>&#123;</span><br><span class="line">  ctor.super_ = superCtor;</span><br><span class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: ctor,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  People.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">inherits(Man, People);</span><br><span class="line">Man.prototype.fun = ...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文参考自&lt;a href=&quot;https://www.cnblogs.com/ranyonsue/p/11201730.html&quot;&gt;js继承的6种方式&lt;/a&gt;，感谢。&lt;/p&gt;
&lt;p&gt;想要继承，就必须先有父类（继承谁，提供谁的属性）&lt;/p&gt;
&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>用setTimeout、clearTimeout实现setInterval、clearInterval</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/Timeout%E5%AE%9E%E7%8E%B0Interval/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/Timeout%E5%AE%9E%E7%8E%B0Interval/</id>
    <published>2021-09-24T06:16:00.435Z</published>
    <updated>2021-09-24T06:16:00.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单实现setInterval"><a href="#简单实现setInterval" class="headerlink" title="简单实现setInterval"></a>简单实现setInterval</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySetInterval = <span class="function"><span class="keyword">function</span>(<span class="params">f, time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个递归函数，持续调用定时器</span></span><br><span class="line">    <span class="keyword">var</span> excute = <span class="function"><span class="keyword">function</span> (<span class="params">f, time</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            f();</span><br><span class="line">            excute(f, time);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">    excute(f, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="改进实现clearInterval"><a href="#改进实现clearInterval" class="headerlink" title="改进实现clearInterval"></a>改进实现clearInterval</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeWorker = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> mySetInterval = <span class="function"><span class="keyword">function</span>(<span class="params">f, time</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个key，来标识此定时器</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">Symbol</span>();</span><br><span class="line">    <span class="comment">//定义一个递归函数，持续调用定时器</span></span><br><span class="line">    <span class="keyword">var</span> excute = <span class="function"><span class="keyword">function</span>(<span class="params">f, time</span>) </span>&#123;</span><br><span class="line">        timeWorker[key] = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            f();</span><br><span class="line">            excute(f, time);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">    excute(f, time);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myClearInterval = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeWorker.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeWorker[key]);</span><br><span class="line">        <span class="keyword">delete</span> timeWorker[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单实现setInterval&quot;&gt;&lt;a href=&quot;#简单实现setInterval&quot; class=&quot;headerlink&quot; title=&quot;简单实现setInterval&quot;&gt;&lt;/a&gt;简单实现setInterval&lt;/h1&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="手撕" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E6%89%8B%E6%92%95/"/>
    
    <category term="JS" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>hexo+gitee搭建个人博客</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/hexo+gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/hexo+gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-09-24T06:16:00.435Z</published>
    <updated>2021-09-24T06:16:00.435Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一步：</strong>新建仓库。注意仓库路径名称。</p><p><img src="C:\Users\33594\AppData\Roaming\Typora\typora-user-images\image-20210921180245347.png" alt="image-20210921180245347"></p><p><img src="C:\Users\33594\AppData\Roaming\Typora\typora-user-images\image-20210921180157229.png" alt="image-20210921180157229"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;新建仓库。注意仓库路径名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\33594\AppData\Roaming\Typora\typora-user-images\image-20210921180245347.png</summary>
      
    
    
    
    <category term="其他" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="博客" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>webpack 相关面试题</title>
    <link href="https://github.com/vaneao/vaneao.github.io/blog/webpack%20%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://github.com/vaneao/vaneao.github.io/blog/webpack%20%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-09-24T06:16:00.435Z</published>
    <updated>2021-09-24T06:16:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>文章参考自<a href="http://mp.weixin.qq.com/s?__biz=MzA4ODUzNTE2Nw==&mid=2451055139&idx=1&sn=82f0d04cda71d288f86ac133c1aa2e59&chksm=87c43b33b0b3b2254e1a39611a8b65c17e5a07497c5551c34a43512c533675866f7b65c0840d&mpshare=1&scene=24&srcid=0420IoE5iC1pnbHdJlLJhBph&sharer_sharetime=1618851250375&sharer_shareid=9696fea7a5d51803a1503d2efcaa547e#rd">当面试官问Webpack的时候他想知道什么</a>，<a href="https://juejin.cn/post/6844904094281236487#heading-0">「吐血整理」再来一打Webpack面试题</a>，感谢。</p><h2 id="你知道-webpack-的作用是什么吗？"><a href="#你知道-webpack-的作用是什么吗？" class="headerlink" title="你知道 webpack 的作用是什么吗？"></a>你知道 webpack 的作用是什么吗？</h2><p>从官网上的描述我们其实不难理解，<code>webpack</code> 的作用其实有以下几点：</p><ul><li>模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。</li><li>编译兼容。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过<code>webpack</code>的<code>Loader</code>机制，不仅仅可以帮助我们对代码做<code>polyfill</code>，还可以编译转换诸如<code>.less, .vue, .jsx</code>这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。</li><li>能力扩展。通过<code>webpack</code>的<code>Plugin</code>机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。</li></ul><hr><hr><h2 id="说一下模块打包运行原理"><a href="#说一下模块打包运行原理" class="headerlink" title="说一下模块打包运行原理"></a>说一下模块打包运行原理</h2><p><code>Webpack</code> 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p><p>首先我们应该简单了解一下<code>webpack</code>的整个打包流程：</p><ol><li>读取<code>webpack</code>的配置参数；</li><li>启动<code>webpack</code>，创建<code>Compiler</code>对象并开始解析项目；</li><li>从入口文件（<code>entry</code>）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；</li><li>对不同文件类型的依赖模块文件使用对应的<code>Loader</code>进行编译，最终转为<code>Javascript</code>文件；</li><li>整个过程中<code>webpack</code>会通过发布订阅模式，向外抛出一些<code>hooks</code>，而<code>webpack</code>的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</li></ol><p>其中文件的解析与构建是一个比较复杂的过程，在<code>webpack</code>源码中主要依赖于<code>compiler</code>和<code>compilation</code>两个核心对象实现。</p><p><code>compiler</code>对象是一个全局单例，他负责把控整个<code>webpack</code>打包的构建流程。<br><code>compilation</code>对象是每一次构建的上下文对象，它包含了当次构建所需要的所有信息，每次热更新和重新构建，<code>compiler</code>都会重新生成一个新的<code>compilation</code>对象，负责此次更新的构建过程。</p><p>而每个模块间的依赖关系，则依赖于<code>AST</code>语法树。每个模块文件在通过<code>Loader</code>解析完成之后，会通过<code>acorn</code>库生成模块代码的<code>AST</code>语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。</p><p>最终<code>Webpack</code>打包出来的<code>bundle</code>文件是一个<code>IIFE</code>的执行函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 5 打包的bundle文件内容</span></span><br><span class="line"></span><br><span class="line">(<span class="function">() =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">    <span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line">        <span class="string">&#x27;file-A-path&#x27;</span>: (<span class="function">(<span class="params">modules</span>) =&gt;</span> &#123; <span class="comment">// ... &#125;)</span></span><br><span class="line">        <span class="string">&#x27;index-file-path&#x27;</span>: (<span class="function">(<span class="params">__unused_webpack_module, __unused_webpack_exports, __webpack_require__</span>) =&gt;</span> &#123; <span class="comment">// ... &#125;)</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The module cache</span></span><br><span class="line">    <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The require function</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Check if module is in cache</span></span><br><span class="line">        <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">        <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">                <span class="comment">// no module.id needed</span></span><br><span class="line">                <span class="comment">// no module.loaded needed</span></span><br><span class="line">                <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Execute the module function</span></span><br><span class="line">        __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the exports of the module</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// startup</span></span><br><span class="line">    <span class="comment">// Load entry module and return exports</span></span><br><span class="line">    <span class="comment">// This entry module can&#x27;t be inlined because the eval devtool is used.</span></span><br><span class="line">    <span class="keyword">var</span> __webpack_exports__ = __webpack_require__(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和<code>webpack4</code>相比，<code>webpack5</code>打包出来的<code>bundle</code>做了相当的精简。在上面的打包<code>demo</code>中，整个立即执行函数里边只有三个变量和一个函数方法，<code>__webpack_modules__</code>存放了编译后的各个文件模块的<code>JS</code>内容，<code>__webpack_module_cache__</code>用来做模块缓存，<code>__webpack_require__</code>是<code>Webpack</code>内部实现的一套依赖引入函数。最后一句则是代码运行的起点，从入口文件开始，启动整个项目。</p><p>其中值得一提的是<code>__webpack_require__</code>模块引入函数，我们在模块化开发的时候，通常会使用<code>ES Module</code>或者<code>CommonJS</code>规范导出/引入依赖模块，<code>webpack</code>打包编译的时候，会统一替换成自己的<code>__webpack_require__</code>来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性。</p><hr><hr><h2 id="你知道sourceMap是什么吗？"><a href="#你知道sourceMap是什么吗？" class="headerlink" title="你知道sourceMap是什么吗？"></a>你知道sourceMap是什么吗？</h2><p>提到<code>sourceMap</code>，很多小伙伴可能会立刻想到<code>Webpack</code>配置里边的<code>devtool</code>参数，以及对应的<code>eval</code>，<code>eval-cheap-source-map</code>等等可选值以及它们的含义。除了知道不同参数之间的区别以及性能上的差异外，我们也可以一起了解一下<code>sourceMap</code>的实现方式。</p><p><code>sourceMap</code>是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中<code>debug</code>问题会带来非常糟糕的体验，<code>sourceMap</code>可以帮助我们快速定位到源代码的位置，提高我们的开发效率。<code>sourceMap</code>其实并不是<code>Webpack</code>特有的功能，而是<code>Webpack</code>支持<code>sourceMap</code>，像<code>JQuery</code>也支持<code>souceMap</code>。</p><p>既然是一种源码的映射，那必然就需要有一份映射的文件，来标记混淆代码里对应的源码的位置，通常这份映射文件以<code>.map</code>结尾，里边的数据结构大概长这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : <span class="number">3</span>,                          <span class="comment">// Source Map版本</span></span><br><span class="line">  <span class="string">&quot;file&quot;</span>: <span class="string">&quot;out.js&quot;</span>,                       <span class="comment">// 输出文件（可选）</span></span><br><span class="line">  <span class="string">&quot;sourceRoot&quot;</span>: <span class="string">&quot;&quot;</span>,                       <span class="comment">// 源文件根目录（可选）</span></span><br><span class="line">  <span class="string">&quot;sources&quot;</span>: [<span class="string">&quot;foo.js&quot;</span>, <span class="string">&quot;bar.js&quot;</span>],        <span class="comment">// 源文件列表</span></span><br><span class="line">  <span class="string">&quot;sourcesContent&quot;</span>: [<span class="literal">null</span>, <span class="literal">null</span>],         <span class="comment">// 源内容列表（可选，和源文件列表顺序一致）</span></span><br><span class="line">  <span class="string">&quot;names&quot;</span>: [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;maps&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;fun&quot;</span>], <span class="comment">// mappings使用的符号名称列表</span></span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: <span class="string">&quot;A,AAAB;;ABCDE;&quot;</span>            <span class="comment">// 带有编码映射数据的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>mappings</code>数据有如下规则：</p><ul><li>生成文件中的一行的每个组用“;”分隔；</li><li>每一段用“,”分隔；</li><li>每个段由1、4或5个可变长度字段组成；</li></ul><p>有了这份映射文件，我们只需要在我们的压缩代码的最末端加上这句注释，即可让<code>sourceMap</code>生效：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//# sourceURL=/path/to/file.js.map</span></span><br></pre></td></tr></table></figure><p>有了这段注释后，浏览器就会通过<code>sourceURL</code>去获取这份映射文件，通过解释器解析后，实现源码和混淆代码之间的映射。因此<code>sourceMap</code>其实也是一项需要浏览器支持的技术。</p><p>如果我们仔细查看<code>webpack</code>打包出来的<code>bundle</code>文件，就可以发现在默认的<code>development</code>开发模式下，每个<code>_webpack_modules__</code>文件模块的代码最末端，都会加上<code>//# sourceURL=webpack://file-path?</code>，从而实现对<code>sourceMap</code>的支持。</p><p><code>sourceMap</code>映射表的生成有一套较为复杂的规则，有兴趣的小伙伴可以看看以下文章，帮助理解<code>sourceMap</code>的原理实现：</p><p><a href="https://blog.fundebug.com/2018/10/12/understanding_frontend_source_map/">Source Map的原理探究</a></p><p><a href="https://docs.microsoft.com/zh-cn/archive/blogs/davidni/source-maps-under-the-hood-vlq-base64-and-yoda">Source Maps under the hood – VLQ, Base64 and Yoda</a></p><hr><hr><h2 id="是否写过Loader？简单描述一下编写loader的思路？"><a href="#是否写过Loader？简单描述一下编写loader的思路？" class="headerlink" title="是否写过Loader？简单描述一下编写loader的思路？"></a>是否写过Loader？简单描述一下编写loader的思路？</h2><p>从上面的打包代码我们其实可以知道，<code>Webpack</code>最后打包出来的成果是一份<code>Javascript</code>代码，实际上在<code>Webpack</code>内部默认也只能够处理<code>JS</code>模块代码，在打包过程中，会默认把所有遇到的文件都当作 <code>JavaScript</code>代码进行解析，因此当项目存在非<code>JS</code>类型文件时，我们需要先对其进行必要的转换，才能继续执行打包任务，这也是<code>Loader</code>机制存在的意义。</p><p><code>Loader</code>的配置使用我们应该已经非常的熟悉：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...other config</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/^your-regExp$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="attr">loader</span>: <span class="string">&#x27;loader-name-A&#x27;</span>,</span><br><span class="line">          &#125;, </span><br><span class="line">          &#123;</span><br><span class="line">             <span class="attr">loader</span>: <span class="string">&#x27;loader-name-B&#x27;</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过配置可以看出，针对每个文件类型，<code>loader</code>是支持以数组的形式配置多个的，因此当<code>Webpack</code>在转换该文件类型的时候，会按顺序链式调用每一个<code>loader</code>，前一个<code>loader</code>返回的内容会作为下一个<code>loader</code>的入参。因此<code>loader</code>的开发需要遵循一些规范，比如返回值必须是标准的<code>JS</code>代码字符串，以保证下一个<code>loader</code>能够正常工作，同时在开发上需要严格遵循“单一职责”，只关心<code>loader</code>的输出以及对应的输出。</p><p><code>loader</code>函数中的<code>this</code>上下文由<code>webpack</code>提供，可以通过<code>this</code>对象提供的相关属性，获取当前<code>loader</code>需要的各种信息数据，事实上，这个<code>this</code>指向了一个叫<code>loaderContext的loader-runner</code>特有对象。有兴趣的小伙伴可以自行阅读源码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content = doSomeThing2JsString(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 loader 配置了 options 对象，那么this.query将指向 options</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">this</span>.query;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以用作解析其他模块路径的上下文</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this.context&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this.callback 参数：</span></span><br><span class="line"><span class="comment">     * error：Error | null，当 loader 出错时向外抛出一个 error</span></span><br><span class="line"><span class="comment">     * content：String | Buffer，经过 loader 编译后需要导出的内容</span></span><br><span class="line"><span class="comment">     * sourceMap：为方便调试生成的编译后内容的 source map</span></span><br><span class="line"><span class="comment">     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.callback(<span class="literal">null</span>, content);</span><br><span class="line">    <span class="comment">// or return content;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的开发文档可以直接查看官网的 <a href="https://www.webpackjs.com/api/loaders/">Loader API</a>。</p><hr><hr><h2 id="是否写过Plugin？简单描述一下编写plugin的思路？"><a href="#是否写过Plugin？简单描述一下编写plugin的思路？" class="headerlink" title="是否写过Plugin？简单描述一下编写plugin的思路？"></a>是否写过Plugin？简单描述一下编写plugin的思路？</h2><p>如果说<code>Loader</code>负责文件转换，那么<code>Plugin</code>便是负责功能扩展。<code>Loader</code>和<code>Plugin</code>作为<code>Webpack</code>的两个重要组成部分，承担着两部分不同的职责。</p><p>上文已经说过，<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现自己想要的功能。</p><p>既然基于发布订阅模式，那么知道<code>Webpack</code>到底提供了哪些事件钩子供插件开发者使用是非常重要的，上文提到过<code>compiler</code>和<code>compilation</code>是<code>Webpack</code>两个非常核心的对象，其中<code>compiler</code>暴露了和 <code>Webpack</code>整个生命周期相关的钩子（<code>compiler-hooks</code>），而<code>compilation</code>则暴露了与模块和依赖有关的粒度更小的事件钩子（<code>Compilation Hooks</code>）。</p><p><code>Webpack</code>的事件机制基于<code>webpack</code>自己实现的一套<code>Tapable</code>事件流方案（<a href="https://github.com/webpack/tapable">github</a>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tapable的简单使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; SyncHook &#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在this.hooks中定义所有的钩子事件</span></span><br><span class="line">        <span class="built_in">this</span>.hooks = &#123;</span><br><span class="line">            <span class="attr">accelerate</span>: <span class="keyword">new</span> SyncHook([<span class="string">&quot;newSpeed&quot;</span>]),</span><br><span class="line">            <span class="attr">brake</span>: <span class="keyword">new</span> SyncHook(),</span><br><span class="line">            <span class="attr">calculateRoutes</span>: <span class="keyword">new</span> AsyncParallelHook([<span class="string">&quot;source&quot;</span>, <span class="string">&quot;target&quot;</span>, <span class="string">&quot;routesList&quot;</span>])</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="comment">// 通过调用tap方法即可增加一个消费者，订阅对应的钩子事件了</span></span><br><span class="line">myCar.hooks.brake.tap(<span class="string">&quot;WarningLampPlugin&quot;</span>, <span class="function">() =&gt;</span> warningLamp.on());</span><br></pre></td></tr></table></figure><p><code>Plugin</code>的开发和开发<code>Loader</code>一样，需要遵循一些开发上的规范和原则：</p><ul><li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例；</li><li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件;</li><li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住;</li></ul><p>了解了以上这些内容，想要开发一个 <code>Webpack Plugin</code>，其实也并不困难。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">// 找到合适的事件钩子，实现自己的插件功能</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation: 当前打包构建流程的上下文</span></span><br><span class="line">        <span class="built_in">console</span>.log(compilation);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的开发文档可以直接查看官网的 <a href="https://www.webpackjs.com/api/plugins/">Plugin API</a>。</p><hr><hr><h2 id="有哪些常见的Loader？你用过哪些Loader？"><a href="#有哪些常见的Loader？你用过哪些Loader？" class="headerlink" title="有哪些常见的Loader？你用过哪些Loader？"></a>有哪些常见的Loader？你用过哪些Loader？</h2><ul><li><code>raw-loader</code>：加载文件原始内容（<code>utf-8</code>）；</li><li><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 <code>URL</code> 去引用输出的文件 (处理图片和字体)；</li><li><code>url-loader</code>：与 <code>file-loader</code> 类似，区别是用户可以设置一个阈值，大于阈值会交给<code>file-loader</code> 处理，小于阈值时返回文件 <code>base64</code> 形式编码 (处理图片和字体)；</li><li><code>source-map-loader</code>：加载额外的 <code>Source Map</code> 文件，以方便断点调试；</li><li><code>svg-inline-loader</code>：将压缩后的 <code>SVG</code> 内容注入代码中；</li><li><code>image-loader</code>：加载并且压缩图片文件；</li><li><code>json-loader</code>：加载 <code>JSON</code> 文件（默认包含）；</li><li><code>handlebars-loader</code>: 将 <code>Handlebars</code> 模版编译成函数并返回；</li><li><code>babel-loader</code>：把 <code>ES6</code> 转换成 <code>ES5</code>；</li><li><code>ts-loader</code>: 将 <code>TypeScript</code> 转换成 <code>JavaScript</code>；</li><li><code>awesome-typescript-loader</code>：将 <code>TypeScript</code> 转换成 <code>JavaScript</code>，性能优于 <code>ts-loader</code>；</li><li><code>sass-loader</code>：将<code>SCSS/SASS</code>代码转换成<code>CSS</code>；</li><li><code>css-loader</code>：加载 <code>CSS</code>，支持模块化、压缩、文件导入等特性；</li><li><code>style-loader</code>：把 <code>CSS</code> 代码注入到 <code>JavaScript</code> 中，通过 <code>DOM</code> 操作去加载 <code>CSS</code>；</li><li><code>postcss-loader</code>：扩展 <code>CSS</code> 语法，使用下一代 <code>CSS</code>，可以配合 <code>autoprefixer</code> 插件自动补齐 <code>CSS3</code> 前缀；</li><li><code>eslint-loader</code>：通过 <code>ESLint</code> 检查 <code>JavaScript</code> 代码；</li><li><code>tslint-loader</code>：通过 <code>TSLint</code> 检查 <code>TypeScript</code> 代码；</li><li><code>mocha-loader</code>：加载 <code>Mocha</code> 测试用例的代码；</li><li><code>coverjs-loader</code>：计算测试的覆盖率；</li><li><code>vue-loader</code>：加载 <code>Vue.js</code> 单文件组件；</li><li><code>i18n-loader</code>: 国际化；</li><li><code>cache-loader</code>: 可以在一些性能开销较大的 <code>Loader</code> 之前添加，目的是将结果缓存到磁盘里；</li></ul><p>更多 <a href="https://webpack.docschina.org/loaders/">Loader</a> 请参考官网。</p><hr><hr><h2 id="有哪些常见的Plugin？你用过哪些Plugin？"><a href="#有哪些常见的Plugin？你用过哪些Plugin？" class="headerlink" title="有哪些常见的Plugin？你用过哪些Plugin？"></a>有哪些常见的Plugin？你用过哪些Plugin？</h2><ul><li><code>define-plugin</code>：定义环境变量 (<code>Webpack4</code> 之后指定 <code>mode</code> 会自动配置)；</li><li><code>ignore-plugin</code>：忽略部分文件；</li><li><code>html-webpack-plugin</code>：简化 <code>HTML</code> 文件创建 (依赖于 <code>html-loader</code>)；</li><li><code>web-webpack-plugin</code>：可方便地为单页应用输出 <code>HTML</code>，比 <code>html-webpack-plugin</code> 好用；</li><li><code>uglifyjs-webpack-plugin</code>：不支持 <code>ES6</code> 压缩 (<code>Webpack4</code> 以前)；</li><li><code>terser-webpack-plugin</code>: 支持压缩 <code>ES6 (Webpack4)</code>；</li><li><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度；</li><li><code>mini-css-extract-plugin</code>: 分离样式文件，<code>CSS</code> 提取为独立文件，支持按需加载 (替代<code>extract-text-webpack-plugin</code>)；</li><li><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能；</li><li><code>clean-webpack-plugin</code>: 目录清理；</li><li><code>ModuleConcatenationPlugin</code>: 开启 <code>Scope Hoisting</code>；</li><li><code>speed-measure-webpack-plugin</code>: 可以看到每个 <code>Loader</code> 和 <code>Plugin</code> 执行耗时 (整个打包耗时、每个 <code>Plugin</code> 和 <code>Loader</code> 耗时)；</li><li><code>webpack-bundle-analyzer</code>: 可视化 <code>Webpack</code> 输出文件的体积 (业务组件、依赖第三方模块)；</li></ul><p>更多 <a href="https://webpack.docschina.org/plugins/">Plugin</a> 请参考官网。</p><hr><hr><h2 id="Loader和Plugin的区别？"><a href="#Loader和Plugin的区别？" class="headerlink" title="Loader和Plugin的区别？"></a>Loader和Plugin的区别？</h2><ul><li><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。<br>因为 <code>Webpack</code> 只认识 <code>JavaScript</code>，所以 <code>Loader</code> 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p></li><li><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 <code>Webpack</code> 的功能，在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。</p></li><li><p><code>Loader</code> 在 <code>module.rules</code> 中配置，作为模块的解析规则，类型为数组。每一项都是一个 <code>Object</code>，内部包含了 <code>test</code>(类型文件)、<code>loader</code>、<code>options</code> (参数)等属性。<br><code>Plugin</code> 在 <code>plugins</code> 中单独配置，类型为数组，每一项是一个 <code>Plugin</code> 的实例，参数都通过构造函数传入。</p></li></ul><hr><hr><h2 id="Webpack构建流程"><a href="#Webpack构建流程" class="headerlink" title="Webpack构建流程"></a>Webpack构建流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li><code>初始化参数</code>：从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数。</li><li><code>开始编译</code>：用上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li><li><code>确定入口</code>：根据配置中的 <code>entry</code> 找出所有的入口文件。</li><li><code>编译模块</code>：从入口文件出发，调用所有配置的 <code>Loader</code> 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li><li><code>完成模块编译</code>：在经过第 4 步使用 <code>Loader</code> 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</li><li><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 <code>Webpack</code> 提供的 <code>API</code> 改变 <code>Webpack</code> 的运行结果。</p><p>简单说：</p><ul><li><code>初始化</code>：启动构建，读取与合并配置参数，加载 <code>Plugin</code>，实例化 <code>Compiler</code>。</li><li><code>编译</code>：从 <code>Entry</code> 出发，针对每个 <code>Module</code> 串行调用对应的 <code>Loader</code> 去翻译文件的内容，再找到该 <code>Module</code> 依赖的 <code>Module</code>，递归地进行编译处理。</li><li><code>输出</code>：将编译后的 <code>Module</code> 组合成 <code>Chunk</code>，将 <code>Chunk</code> 转换成文件，输出到文件系统中。</li></ul><p>对源码感兴趣的同学可以移步我的另一篇专栏从源码<a href="https://juejin.cn/post/6844904046294204429">窥探Webpack4.x原理</a>。</p><hr><hr><h2 id="使用webpack开发时，你用过哪些可以提高效率的插件？"><a href="#使用webpack开发时，你用过哪些可以提高效率的插件？" class="headerlink" title="使用webpack开发时，你用过哪些可以提高效率的插件？"></a>使用webpack开发时，你用过哪些可以提高效率的插件？</h2><ul><li><code>webpack-dashboard</code>：可以更友好的展示相关打包信息。</li><li><code>webpack-merge</code>：提取公共配置，减少重复配置代码。</li><li><code>speed-measure-webpack-plugin</code>：简称 <code>SMP</code>，分析出 <code>Webpack</code> 打包过程中 <code>Loader</code> 和 <code>Plugin</code> 的耗时，有助于找到构建过程中的性能瓶颈。</li><li><code>size-plugin</code>：监控资源体积变化，尽早发现问题。</li><li><code>HotModuleReplacementPlugin</code>：模块热替换。</li></ul><h2 id="文件监听原理？"><a href="#文件监听原理？" class="headerlink" title="文件监听原理？"></a>文件监听原理？</h2><p>在发现源码发生变化时，自动重新构建出新的输出文件。</p><p><code>Webpack</code>开启监听模式，有两种方式：</p><ul><li>启动 <code>webpack</code> 命令时，带上 <code>--watch</code> 参数。</li><li>在配置 <code>webpack.config.js</code> 中设置 <code>watch:true</code>。</li></ul><p>缺点：每次需要手动刷新浏览器。</p><p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 <code>aggregateTimeout</code> 后再执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;    </span><br><span class="line">    <span class="comment">// 默认false,也就是不开启    </span></span><br><span class="line">    <span class="attr">watch</span>: <span class="literal">true</span>,    </span><br><span class="line">    <span class="comment">// 只有开启监听模式时，watchOptions才有意义    </span></span><br><span class="line">    <span class="attr">watchOptions</span>: &#123;        </span><br><span class="line">        <span class="comment">// 默认为空，不监听的文件或者文件夹，支持正则匹配        </span></span><br><span class="line">        <span class="attr">ignored</span>: <span class="regexp">/node_modules/</span>,        </span><br><span class="line">        <span class="comment">// 监听到变化发生后会等300ms再去执行，默认300ms </span></span><br><span class="line">        aggregateTimeout:<span class="number">300</span>,        </span><br><span class="line">        <span class="comment">// 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次        </span></span><br><span class="line">        <span class="attr">poll</span>:<span class="number">1000</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="Webpack-热更新原理"><a href="#Webpack-热更新原理" class="headerlink" title="Webpack 热更新原理"></a>Webpack 热更新原理</h2><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p><code>HMR</code> 的核心就是客户端从服务端拉去更新后的文件，准确的说是 <code>chunk diff</code> （<code>chunk</code> 需要更新的部分），实际上 <code>WDS</code> 与浏览器之间维护了一个 <code>Websocket</code>，当本地资源发生变化时，<code>WDS</code> 会向浏览器推送更新，并带上构建时的 <code>hash</code>，让客户端与上一次资源进行对比。客户端对比出差异后会向 <code>WDS</code> 发起 <code>Ajax</code> 请求来获取更改内容（文件列表、<code>hash</code>），这样客户端就可以再借助这些信息继续向 <code>WDS</code> 发起 <code>jsonp</code> 请求获取该 <code>chunk</code> 的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由   <code>HotModulePlugin</code> 来完成，提供了相关 <code>API</code> 以供开发者针对自身场景进行处理，像 <code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 <code>API</code> 实现 <code>HMR</code>。</p><p>细节请参考 <a href="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a>。</p><hr><hr><h2 id="如何对bundle体积进行监控和分析？"><a href="#如何对bundle体积进行监控和分析？" class="headerlink" title="如何对bundle体积进行监控和分析？"></a>如何对bundle体积进行监控和分析？</h2><p><code>VSCode</code> 中有一个插件 <code>Import Cost</code> 可以帮助我们对引入模块的大小进行实时监测，还可以使用 <code>webpack-bundle-analyzer</code> 生成 <code>bundle</code> 的模块组成图，显示所占体积。</p><p><code>bundlesize</code> 工具包可以进行自动化资源体积监控。</p><hr><hr><h2 id="文件指纹是什么？怎么用？"><a href="#文件指纹是什么？怎么用？" class="headerlink" title="文件指纹是什么？怎么用？"></a>文件指纹是什么？怎么用？</h2><p>文件指纹是打包后输出的文件名的后缀。</p><ul><li><code>Hash</code>：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 <code>hash</code> 值就会更改。</li><li><code>Chunkhash</code>：和 <code>Webpack</code> 打包的 <code>chunk</code> 有关，不同的 <code>entry</code> 会生出不同的 <code>chunkhash</code>。</li><li><code>Contenthash</code>：根据文件内容来定义 <code>hash</code>，文件内容不变，则 <code>contenthash</code> 不变。</li></ul><h3 id="JS的文件指纹设置"><a href="#JS的文件指纹设置" class="headerlink" title="JS的文件指纹设置"></a>JS的文件指纹设置</h3><p>设置 <code>output</code> 的 <code>filename</code>，用 <code>chunkhash</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;    </span><br><span class="line">    <span class="attr">entry</span>: &#123;        </span><br><span class="line">        <span class="attr">app</span>: <span class="string">&#x27;./scr/app.js&#x27;</span>,        </span><br><span class="line">        <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span>    </span><br><span class="line">    &#125;,   </span><br><span class="line">    <span class="attr">output</span>: &#123;        </span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name][chunkhash:8].js&#x27;</span>,        </span><br><span class="line">        <span class="attr">path</span>:__dirname + <span class="string">&#x27;/dist&#x27;</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS的文件指纹设置"><a href="#CSS的文件指纹设置" class="headerlink" title="CSS的文件指纹设置"></a>CSS的文件指纹设置</h3><p>设置 <code>MiniCssExtractPlugin</code> 的 <code>filename</code>，使用 <code>contenthash</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;    </span><br><span class="line">    <span class="attr">entry</span>: &#123;        </span><br><span class="line">        <span class="attr">app</span>: <span class="string">&#x27;./scr/app.js&#x27;</span>,        </span><br><span class="line">        <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span>    </span><br><span class="line">    &#125;,   </span><br><span class="line">    <span class="attr">output</span>: &#123;        </span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name][chunkhash:8].js&#x27;</span>,        </span><br><span class="line">        <span class="attr">path</span>:__dirname + <span class="string">&#x27;/dist&#x27;</span>    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="attr">plugins</span>:[        </span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;            </span><br><span class="line">            <span class="attr">filename</span>: <span class="string">`[name][contenthash:8].css`</span>        </span><br><span class="line">        &#125;)    </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h3><p>设置 <code>file-loader</code> 的 <code>name</code>，使用 <code>hash</code>。</p><p>占位符名称及含义:</p><ul><li><code>ext</code> 资源后缀名</li><li><code>name</code> 文件名称</li><li><code>path</code> 文件的相对路径</li><li><code>folder</code> 文件所在的文件夹</li><li><code>contenthash</code> 文件的内容 <code>hash</code>，默认是 <code>md5</code> 生成</li><li><code>hash</code> 文件内容的 <code>hash</code>，默认是 <code>md5</code> 生成</li><li><code>emoji</code> 一个随机的指代文件内容的 <code>emoji</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;   </span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,    </span><br><span class="line">    <span class="attr">output</span>: &#123;        </span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;bundle.js&#x27;</span>,        </span><br><span class="line">        <span class="attr">path</span>:path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="attr">module</span>:&#123;        </span><br><span class="line">        <span class="attr">rules</span>:[&#123;            </span><br><span class="line">            <span class="attr">test</span>:<span class="regexp">/\.(png|svg|jpg|gif)$/</span>,            </span><br><span class="line">            use:[&#123;                </span><br><span class="line">                <span class="attr">loader</span>:<span class="string">&#x27;file-loader&#x27;</span>,                </span><br><span class="line">                <span class="attr">options</span>:&#123;                    </span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;img/[name][hash:8].[ext]&#x27;</span>      </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;]        </span><br><span class="line">        &#125;]    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><hr><h2 id="在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"><a href="#在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？" class="headerlink" title="在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"></a>在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？</h2><p>可以使用 <code>enforce</code> 强制执行 <code>loader</code> 的作用顺序，<code>pre</code> 代表在所有正常 <code>loader</code> 之前执行，<code>post</code> 是所有 <code>loader</code> 之后执行。(<code>inline</code> 官方不推荐使用)</p><hr><hr><h2 id="如何优化-Webpack-的构建速度？"><a href="#如何优化-Webpack-的构建速度？" class="headerlink" title="如何优化 Webpack 的构建速度？"></a>如何优化 Webpack 的构建速度？</h2><ul><li>使用 <code>高版本</code> 的 <code>Webpack</code> 和 <code>Node.js</code>。</li><li>多进程/多实例构建：HappyPack(不维护了)、<code>thread-loader</code>。</li><li>压缩代码<ul><li>多进程并行压缩：<ul><li>webpack-paralle-uglify-plugin</li><li>uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)</li><li>terser-webpack-plugin 开启 parallel 参数</li></ul></li><li>通过 <code>mini-css-extract-plugin</code> 提取 <code>Chunk</code> 中的 <code>CSS</code> 代码到单独文件，通过 <code>css-loader</code> 的 <code>minimize</code> 选项开启 <code>cssnano</code> 压缩 <code>CSS</code>。</li></ul></li><li>图片压缩<ul><li>使用基于 <code>Node</code> 库的 <code>imagemin</code>（很多定制选项、可以处理多种图片格式）。</li><li>配置 <code>image-webpack-loader</code>。</li></ul></li><li>缩小打包作用域<ul><li><code>exclude/include</code> (确定 <code>loader</code> 规则范围)</li><li><code>resolve.modules</code> 指明第三方模块的绝对路径 (减少不必要的查找)</li><li><code>resolve.mainFields</code> 只采用 <code>main</code> 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li><li><code>resolve.extensions</code> 尽可能减少后缀尝试的可能性</li><li><code>noParse</code> 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 <code>bundle</code> 中，注意被忽略掉的文件里不应该包含 <code>import、require、define</code> 等模块化语句)</li><li><code>IgnorePlugin</code> (完全排除模块)</li><li>合理使用 <code>alias</code></li></ul></li><li>提取页面公共资源<ul><li>基础包分离<ul><li>使用 <code>html-webpack-externals-plugin</code>，将基础包通过 <code>CDN</code> 引入，不打入 <code>bundle</code> 中</li><li>使用 <code>SplitChunksPlugin</code> 进行(公共脚本、基础包、页面公共文件)分离(<code>Webpack4</code>内置) ，替代了 <code>CommonsChunkPlugin</code> 插件</li></ul></li></ul></li><li>DLL<ul><li>使用 <code>DllPlugin</code> 进行分包，使用 <code>DllReferencePlugin</code>(索引链接) 对 <code>manifest.json</code> 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li><li><code>HashedModuleIdsPlugin</code> 可以解决模块数字 <code>id</code> 问题。</li></ul></li><li>充分利用缓存提升二次构建速度<ul><li><code>babel-loader</code> 开启缓存</li><li><code>terser-webpack-plugin</code> 开启缓存</li><li>使用 <code>cache-loader</code> 或者 <code>hard-source-webpack-plugin</code></li></ul></li><li>Tree shaking<ul><li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的<code>bundle</code>中去掉(只能对<code>ES6 Modlue</code>生效) 开发中尽可能使用<code>ES6 Module</code>的模块，提高<code>tree shaking</code>效率。</li><li>禁用 <code>babel-loader</code> 的模块依赖解析，否则 <code>Webpack</code> 接收到的就都是转换过的 <code>CommonJS</code> 形式的模块，无法进行 <code>tree-shaking</code>。</li><li>使用 <code>PurifyCSS</code>(不在维护) 或者 <code>uncss</code> 去除无用 <code>CSS</code> 代码。<ul><li><code>purgecss-webpack-plugin</code> 和 <code>mini-css-extract-plugin</code> 配合使用(建议)</li></ul></li></ul></li><li>Scope hoisting<ul><li>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。<code>Scope hoisting</code> 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突。</li><li>必须是 <code>ES6</code> 的语法，因为有很多第三方库仍采用 <code>CommonJS</code> 语法，为了充分发挥 <code>Scope hoisting</code> 的作用，需要配置 <code>mainFields</code> 对第三方模块优先采用 <code>jsnext:main</code> 中指向的 <code>ES6</code> 模块化语法。</li></ul></li><li>动态 Polyfill<ul><li>建议采用 <code>polyfill-service</code> 只给用户返回需要的 <code>polyfill</code>，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部<code>polyfill</code>)<br>更多优化请参考<a href="https://www.webpackjs.com/guides/build-performance/">官网-构建性能</a>。</li></ul></li></ul><hr><hr><h2 id="代码分割的本质是什么？有什么意义呢？"><a href="#代码分割的本质是什么？有什么意义呢？" class="headerlink" title="代码分割的本质是什么？有什么意义呢？"></a>代码分割的本质是什么？有什么意义呢？</h2><p>代码分割的本质其实就是在 <code>源代码直接上线</code> 和 <code>打包成唯一脚本main.bundle.js</code> 这两种极端方案之间的一种更适合实际场景的中间状态。</p><p>阿卡丽：荣耀剑下取，均衡乱中求</p><p><strong>「用可接受的服务器性能压力增加来换取更好的用户体验。」</strong></p><p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p><p>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><p>(Easy peezy right)</p><hr><hr><h2 id="聊一聊Babel原理吧"><a href="#聊一聊Babel原理吧" class="headerlink" title="聊一聊Babel原理吧"></a>聊一聊Babel原理吧</h2><p>大多数 <code>JavaScript Parser</code> 遵循 <code>estree</code> 规范，<code>Babel</code> 最初基于 <code>acorn</code>项目(轻量级现代 <code>JavaScript</code> 解析器) <code>Babel</code> 大概分为三大部分：</p><ul><li>解析：将代码转换成 <code>AST</code>。<ul><li>词法分析：将代码(字符串)分割为 <code>token</code> 流，即语法单元成的数组。</li><li>语法分析：分析 <code>token</code> 流(上面生成的数组)并生成 <code>AST</code>。</li></ul></li><li>转换：访问 <code>AST</code> 的节点进行变换操作生产新的 <code>AST</code>。<ul><li><code>Taro</code> 就是利用 <code>babel</code> 完成的小程序语法转换。</li></ul></li><li>生成：以新的 <code>AST</code> 为基础生成代码。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章参考自&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODUzNTE2Nw==&amp;mid=2451055139&amp;idx=1&amp;sn=82f0d04cda71d288f86ac133c1aa2e59&amp;chksm=87c43b33b0b</summary>
      
    
    
    
    <category term="前端" scheme="https://github.com/vaneao/vaneao.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="webpack" scheme="https://github.com/vaneao/vaneao.github.io/blog/tags/webpack/"/>
    
  </entry>
  
</feed>
